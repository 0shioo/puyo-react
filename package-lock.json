import React, { useState, useEffect, useCallback, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';

// --- ぷよぷよ 公式寄せフル実装（React 単一ファイル） ---
// 機能:
// ・縦12×横6（上1行余白）
// ・バッグ方式（出現偏りを防ぐ）
// ・公式風スコア（連鎖ボーナス・同時消しボーナス・色数ボーナス）
// ・回転の壁キック（簡易SRS系）
// ・キャラクター的ぷよ（表情アニメ）
// ・消去アニメーション（縮小・フェード）とパーティクル
// ・ハードドロップ・ソフトドロップ・窒息判定
// 注意: framer-motion を使います。`npm install framer-motion` を事前に。

// ------------------- 定数 -------------------
const COLS = 6;
const ROWS = 13; // index 0: 画面外 spawn 行。表示は 1..12
const VISIBLE_ROWS = ROWS - 1;
const CELL = 44;

const COLOR_PALETTE = [
  { id: 'red', hex: '#ef4444' },
  { id: 'blue', hex: '#3b82f6' },
  { id: 'green', hex: '#10b981' },
  { id: 'yellow', hex: '#f59e0b' },
  { id: 'purple', hex: '#8b5cf6' },
];
const colorHex = (id) => (COLOR_PALETTE.find((c) => c.id === id) || COLOR_PALETTE[0]).hex;

// ------------------- バッグ方式 -------------------
function makeBag() {
  // bag contains color ids, each repeated N times (here 2 per color to create pairs of colors distribution)
  const bag = [];
  COLOR_PALETTE.forEach((c) => {
    bag.push(c.id);
    bag.push(c.id);
  });
  // shuffle
  for (let i = bag.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [bag[i], bag[j]] = [bag[j], bag[i]];
  }
  return bag;
}

class BagGenerator {
  constructor() {
    this.bags = [];
    this.fill();
  }
  fill() {
    while (this.bags.length < 3) this.bags.push(...makeBag());
  }
  next() {
    if (this.bags.length === 0) this.fill();
    return this.bags.shift();
  }
}

// ------------------- フィールドユーティリティ -------------------
const emptyField = () => Array.from({ length: ROWS }, () => Array(COLS).fill(null));
function cloneField(f) { return f.map((r) => [...r]); }
function inBounds(y, x) { return y >= 0 && y < ROWS && x >= 0 && x < COLS; }

// 座標: current { x, y, rotation, colors:[c0,c1] }
function coordsOf(cur) {
  const { x, y, rotation } = cur;
  const r = ((rotation % 4) + 4) % 4;
  if (r === 0) return [[y, x], [y - 1, x]]; // up
  if (r === 1) return [[y, x], [y, x + 1]]; // right
  if (r === 2) return [[y, x], [y + 1, x]]; // down
  return [[y, x], [y, x - 1]]; // left
}

function canPlace(field, cur, dy = 0, dx = 0, rot = cur.rotation) {
  const test = { ...cur, y: cur.y + dy, x: cur.x + dx, rotation: rot };
  const cs = coordsOf(test);
  return cs.every(([yy, xx]) => {
    if (yy < 0) return true; // spawn row can overlap
    if (!inBounds(yy, xx)) return false;
    return field[yy][xx] === null;
  });
}

function commitToField(field, cur) {
  const f = cloneField(field);
  const cs = coordsOf(cur);
  for (let i = 0; i < cs.length; i++) {
    const [yy, xx] = cs[i];
    if (inBounds(yy, xx)) f[yy][xx] = cur.colors[i];
  }
  return f;
}

// ------------------- 発見グループと重力 -------------------
function findGroups(field) {
  const vis = Array.from({ length: ROWS }, () => Array(COLS).fill(false));
  const groups = [];
  for (let y = 0; y < ROWS; y++) {
    for (let x = 0; x < COLS; x++) {
      if (vis[y][x] || field[y][x] === null) continue;
      const color = field[y][x];
      const stack = [[y, x]];
      const group = [];
      while (stack.length) {
        const [cy, cx] = stack.pop();
        if (!inBounds(cy, cx)) continue;
        if (vis[cy][cx]) continue;
        if (field[cy][cx] !== color) continue;
        vis[cy][cx] = true;
        group.push([cy, cx]);
        stack.push([cy - 1, cx], [cy + 1, cx], [cy, cx - 1], [cy, cx + 1]);
      }
      if (group.length >= 4) groups.push(group);
    }
  }
  return groups;
}

function applyGravity(field) {
  const f = cloneField(field);
  for (let x = 0; x < COLS; x++) {
    let write = ROWS - 1;
    for (let y = ROWS - 1; y >= 0; y--) {
      if (f[y][x] !== null) {
        const v = f[y][x];
        f[y][x] = null;
        f[write][x] = v;
        write -= 1;
      }
    }
  }
  return f;
}

// ------------------- スコア（公式寄せの簡易版） -------------------
// 公式は複雑だがここでは代表的なボーナスを導入
const CHAIN_BONUS = [0, 8, 16, 32, 64, 96, 128, 192]; // 指数的に値増やす（簡易）
const SIMULT_BONUS = { 0: 0, 1: 0, 2: 3, 3: 6, 4: 12, 5: 24 }; // 同時消しの色数ボーナス（簡易）

function computeScore(clearedGroups, chainCount) {
  // clearedGroups: array of groups (each group is array of coords). We compute base + bonuses.
  let base = 0;
  const colorSet = new Set();
  const simultaneousCount = clearedGroups.length; // 異なるグループの数（同時消し箇所数）
  let totalPuyos = 0;
  clearedGroups.forEach((g) => {
    totalPuyos += g.length;
    g.forEach(([y, x]) => colorSet.add(`${y},${x}`));
  });
  // base points: puyos * 10
  base = totalPuyos * 10;
  // chain bonus
  const chainBonus = CHAIN_BONUS[Math.min(chainCount, CHAIN_BONUS.length - 1)];
  // simult bonus depending on how many groups/colors simultaneously
  const simultBonus = SIMULT_BONUS[Math.min(simultaneousCount, 5)];
  // color bonus (if multiple colors were involved) - simplistic: +5 per unique color beyond 1
  const uniqueColors = new Set();
  clearedGroups.forEach((g) => g.forEach(([y,x]) => {})); // placeholder
  // final = base * (1 + chainFactor + simultFactor) + small color bonus
  const score = Math.floor(base * (1 + chainBonus / 100 + simultBonus / 100) + (colorSet.size > 1 ? 5 * colorSet.size : 0));
  return score;
}

// ------------------- 壁キック（簡易SRS風） -------------------
const WALL_KICKS = [
  [0, 0], [0, -1], [0, 1], [-1, 0], [1, 0]
];
function tryRotateWithKick(field, cur, dir) {
  const newRot = (cur.rotation + dir + 4) % 4;
  for (const [dy, dx] of WALL_KICKS) {
    if (canPlace(field, cur, dy, dx, newRot)) {
      return { ...cur, rotation: newRot, y: cur.y + dy, x: cur.x + dx };
    }
  }
  return cur; // 何もできず
}

// ------------------- 表情・パーティクル -------------------
function PuyoFace({ colorId, mood = 'normal' }) {
  const hex = colorHex(colorId);
  return (
    <svg viewBox="0 0 100 100" preserveAspectRatio="xMidYMid meet" style={{ width: '100%', height: '100%' }}>
      <defs>
        <radialGradient id={`g-${colorId}`} cx="30%" cy="30%">
          <stop offset="0%" stopColor={hex + 'ee'} />
          <stop offset="70%" stopColor={hex} />
          <stop offset="100%" stopColor={hex + '66'} />
        </radialGradient>
      </defs>
      <g>
        <ellipse cx="50" cy="54" rx="44" ry="36" fill={`url(#g-${colorId})`} stroke="rgba(255,255,255,0.22)" strokeWidth="3" />
        <ellipse cx="36" cy="36" rx="12" ry="8" fill="rgba(255,255,255,0.6)" opacity="0.85" />
        {/* eyes */}
        {mood === 'normal' && (
          <>
            <ellipse cx="40" cy="58" rx="6" ry="8" fill="#fff" />
            <ellipse cx="60" cy="58" rx="6" ry="8" fill="#fff" />
            <circle cx="40" cy="60" r="3" fill="#000" />
            <circle cx="60" cy="60" r="3" fill="#000" />
            <path d="M40 72 Q50 78 60 72" stroke="#2b2b2b" strokeWidth="3" fill="none" strokeLinecap="round" />
          </>
        )}
        {mood === 'happy' && (
          <>
            <ellipse cx="40" cy="56" rx="5" ry="7" fill="#fff" />
            <ellipse cx="60" cy="56" rx="5" ry="7" fill="#fff" />
            <path d="M38 72 Q50 84 62 72" stroke="#1b3" strokeWidth="3" fill="none" strokeLinecap="round" />
          </>
        )}
        {mood === 'surprised' && (
          <>
            <circle cx="40" cy="58" r="4" fill="#fff" />
            <circle cx="60" cy="58" r="4" fill="#fff" />
            <circle cx="50" cy="68" r="5" fill="#222" />
          </>
        )}
      </g>
    </svg>
  );
}

function Puyo({ color, x, y, mood = 'normal', isClearing = false, zIndex = 1 }) {
  const px = x * CELL;
  const py = y * CELL;
  return (
    <motion.div
      layout
      initial={false}
      animate={{ x: px, y: py, scale: isClearing ? 0.2 : 1, opacity: isClearing ? 0 : 1 }}
      transition={{ type: 'spring', stiffness: 600, damping: 28, duration: 0.28 }}
      style={{ position: 'absolute', width: CELL - 6, height: CELL - 6, left: 3, top: 3, zIndex, pointerEvents: 'none' }}
    >
      <PuyoFace colorId={color} mood={mood} />
    </motion.div>
  );
}

// 簡易パーティクル
function Particles({ points = [], color }) {
  return (
    <div style={{ position: 'absolute', inset: 0, pointerEvents: 'none' }}>
      {points.map((p, i) => (
        <motion.div key={i} initial={{ x: p.x * CELL + 8, y: p.y * CELL + 8, opacity: 1, scale: 1 }} animate={{ y: p.y * CELL - 20, opacity: 0, scale: 0.4 }} transition={{ duration: 0.6 }} style={{ position: 'absolute', width: 8, height: 8, borderRadius: 8, background: colorHex(color), mixBlendMode: 'screen' }} />
      ))}
    </div>
  );
}

// ------------------- メインコンポーネント -------------------
export default function OfficialDeepPuyo() {
  const bag = useRef(new BagGenerator());
  const [field, setField] = useState(emptyField());
  const [current, setCurrent] = useState({ x: 2, y: 0, rotation: 0, colors: [bag.current.next(), bag.current.next()] });
  const [next, setNext] = useState([bag.current.next(), bag.current.next()]);
  const [score, setScore] = useState(0);
  const [chain, setChain] = useState(0);
  const [gameOver, setGameOver] = useState(false);
  const [clearingCells, setClearingCells] = useState(new Set());
  const [particles, setParticles] = useState([]);

  const isGameOverField = (f) => {
    for (let x = 0; x < COLS; x++) if (f[1][x]) return true; // line index 1 is top visible row
    return false;
  };

  // 設置→消去→落下のシーケンス
  const lockAndResolve = useCallback(async (f, cur) => {
    let newField = commitToField(f, cur);
    setField(newField);

    if (isGameOverField(newField)) { setGameOver(true); return; }

    let totalScore = 0;
    let chainCount = 0;

    while (true) {
      const groups = findGroups(newField);
      if (groups.length === 0) break;
      chainCount += 1;
      // mark clearing cells
      const toClearSet = new Set();
      groups.forEach((g) => g.forEach(([y, x]) => toClearSet.add(`${y},${x}`)));
      setClearingCells(toClearSet);

      // particle spawn
      const pts = Array.from(toClearSet).map((k) => {
        const [yy, xx] = k.split(',').map(Number);
        return { x: xx, y: yy, color: newField[yy][xx] };
      });
      setParticles(pts);

      // wait for clear animation
      await new Promise((r) => setTimeout(r, 360));

      // clear them
      const afterClear = cloneField(newField);
      toClearSet.forEach((k) => { const [yy, xx] = k.split(',').map(Number); if (inBounds(yy, xx)) afterClear[yy][xx] = null; });
      setField(afterClear);
      setClearingCells(new Set());

      // compute score for this step (we treat simultaneous groups as one simultaneous clear)
      const stepScore = computeScore(groups, chainCount);
      totalScore += stepScore;

      // gravity
      await new Promise((r) => setTimeout(r, 160));
      newField = applyGravity(afterClear);
      setField(newField);

      // spawn short particles fade
      await new Promise((r) => setTimeout(r, 140));
      setParticles([]);
    }

    if (totalScore > 0) setScore((s) => s + totalScore);
    setChain(chainCount);

    // spawn next
    const nextCur = { x: 2, y: 0, rotation: 0, colors: next };
    setCurrent(nextCur);
    setNext([bag.current.next(), bag.current.next()]);
  }, [next]);

  // gravity timer
  useEffect(() => {
    if (gameOver) return;
    const id = setInterval(() => {
      setCurrent((cur) => {
        if (canPlace(field, cur, 1, 0)) return { ...cur, y: cur.y + 1 };
        // lock
        lockAndResolve(field, cur);
        return cur;
      });
    }, 480);
    return () => clearInterval(id);
  }, [field, lockAndResolve, gameOver]);

  // key handling
  useEffect(() => {
    const onKey = (e) => {
      if (gameOver) return;
      if (e.key === 'ArrowLeft') setCurrent((cur) => (canPlace(field, cur, 0, -1) ? { ...cur, x: cur.x - 1 } : cur));
      if (e.key === 'ArrowRight') setCurrent((cur) => (canPlace(field, cur, 0, 1) ? { ...cur, x: cur.x + 1 } : cur));
      if (e.key === 'ArrowDown') setCurrent((cur) => (canPlace(field, cur, 1, 0) ? { ...cur, y: cur.y + 1 } : cur));
      if (e.key === 'z' || e.key === 'Z') setCurrent((cur) => tryRotateWithKick(field, cur, -1));
      if (e.key === 'x' || e.key === 'X') setCurrent((cur) => tryRotateWithKick(field, cur, 1));
      if (e.code === 'Space') {
        setCurrent((cur) => {
          let y = cur.y;
          while (canPlace(field, { ...cur, y }, 1, 0)) y += 1;
          // lock immediately
          const toLock = { ...cur, y };
          lockAndResolve(field, toLock);
          return toLock;
        });
      }
      if (e.key === 'r' || e.key === 'R') {
        bag.current = new BagGenerator();
        setField(emptyField()); setScore(0); setChain(0); setGameOver(false);
        setCurrent({ x: 2, y: 0, rotation: 0, colors: [bag.current.next(), bag.current.next()] });
        setNext([bag.current.next(), bag.current.next()]);
      }
    };
    window.addEventListener('keydown', onKey);
    return () => window.removeEventListener('keydown', onKey);
  }, [field, gameOver, lockAndResolve]);

  // rendered puyos
  const rendered = [];
  for (let y = 1; y < ROWS; y++) {
    for (let x = 0; x < COLS; x++) {
      const col = field[y][x];
      if (col) {
        const key = `${y}-${x}`;
        const isClearing = clearingCells.has(`${y},${x}`);
        rendered.push(<Puyo key={key} color={col} x={x} y={y - 1} mood={isClearing ? 'surprised' : 'normal'} isClearing={isClearing} />);
      }
    }
  }
  const curCoords = coordsOf(current);
  curCoords.forEach(([yy, xx], i) => {
    if (yy >= 1 && inBounds(yy, xx)) rendered.push(<Puyo key={`c-${i}-${yy}-${xx}`} color={current.colors[i]} x={xx} y={yy - 1} mood={'happy'} zIndex={20} />);
  });

  const particlesPoints = particles.map((p) => ({ x: p.x, y: p.y, color: p.color }));

  return (
    <div style={{ minHeight: '100vh', background: 'linear-gradient(180deg,#040612,#0b1530)' }} className="flex items-center justify-center p-8">
      <div style={{ color: '#e6f0ff' }}>
        <h2 style={{ fontSize: 22, fontWeight: 700, marginBottom: 8 }}>ぷよぷよ 公式寄せ — Deep Puyo (Full)</h2>
        <div style={{ display: 'flex', gap: 20 }}>
          <div style={{ position: 'relative', width: COLS * CELL + 12, height: VISIBLE_ROWS * CELL + 12, background: 'linear-gradient(180deg,#061827,#071935)', borderRadius: 10, padding: 6, boxShadow: 'inset 0 0 0 2px rgba(56,189,248,0.06)' }}>
            <div style={{ position: 'absolute', inset: 6, display: 'grid', gridTemplateRows: `repeat(${VISIBLE_ROWS}, ${CELL}px)`, gridTemplateColumns: `repeat(${COLS}, ${CELL}px)`, gap: 4 }}>
              {Array.from({ length: VISIBLE_ROWS * COLS }).map((_, i) => <div key={i} style={{ width: CELL - 6, height: CELL - 6, borderRadius: 10, background: 'rgba(255,255,255,0.02)' }} />)}
            </div>
            <div style={{ position: 'absolute', top: 6, left: 6, width: COLS * CELL, height: VISIBLE_ROWS * CELL }}>
              {rendered}
              <Particles points={particlesPoints} color={'white'} />
            </div>
          </div>

          <div style={{ width: 260 }}>
            <div style={{ marginBottom: 12 }}>
              <div style={{ fontSize: 14, opacity: 0.9 }}>NEXT</div>
              <div style={{ display: 'flex', gap: 8, marginTop: 6 }}>
                {next.map((c, i) => <div key={i} style={{ width: 56, height: 56, borderRadius: 999, background: `radial-gradient(circle at 30% 30%, ${colorHex(c)}cc, ${colorHex(c)}55)`, border: '2px solid rgba(255,255,255,0.06)' }} />)}
              </div>
            </div>
            <div style={{ marginBottom: 12 }}>
              <div style={{ fontSize: 14, opacity: 0.9 }}>SCORE</div>
              <div style={{ fontSize: 22, fontWeight: 700, fontFamily: 'monospace' }}>{score}</div>
            </div>
            <div style={{ marginBottom: 12 }}>
              <div style={{ fontSize: 14, opacity: 0.9 }}>CHAIN</div>
              <div style={{ fontSize: 22, fontWeight: 700, fontFamily: 'monospace' }}>{chain}</div>
            </div>
            {gameOver && <div style={{ color: '#ff7b7b', fontWeight: 700 }}>GAME OVER (Rで再開)</div>}
            <div style={{ marginTop: 10, fontSize: 13, color: '#bcd7ff' }}>操作: ← → 移動 / Z/X 回転（壁キック有） / ↓ ソフトドロップ / Space ハードドロップ / R リスタート</div>
          </div>
        </div>
      </div>
    </div>
  );
}
